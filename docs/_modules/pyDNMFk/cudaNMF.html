

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyDNMFk.cudaNMF &#8212; pyDNMFk 0.0.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pyDNMFk/cudaNMF';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    <p class="title logo__title">pyDNMFk 0.0.1 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../modules.html">pyDNMFk</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../pyDNMFk.html">pyDNMFk package</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for pyDNMFk.cudaNMF</h1><div class="highlight"><pre>
<span></span><span class="c1"># @author: Ismael Boureima</span>
<span class="c1"># Necessary imports for the module</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span> <span class="nn">.toolz</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">amber</span>

<span class="c1"># Try importing cupy modules for GPU support</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
    <span class="kn">import</span> <span class="nn">cupy</span><span class="o">,</span> <span class="nn">cupyx</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] Unable to import Cupy&quot;</span><span class="p">)</span>

<span class="c1"># Try importing necessary cupy backend modules</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">cupy.cuda</span> <span class="kn">import</span> <span class="n">nccl</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] Unable to import NCCL Cupy backend&quot;</span><span class="p">)</span>

<span class="c1"># Importing specific functions from cupy to work with</span>
<span class="kn">from</span> <span class="nn">cupy</span> <span class="kn">import</span> <span class="n">asarray</span>  <span class="k">as</span> <span class="n">_asarray</span>
<span class="kn">from</span> <span class="nn">cupy</span> <span class="kn">import</span> <span class="n">asnumpy</span>  <span class="k">as</span> <span class="n">_asnumpy</span>
<span class="kn">from</span> <span class="nn">cupy</span> <span class="kn">import</span> <span class="n">divide</span>   <span class="k">as</span> <span class="n">_divide</span>
<span class="kn">from</span> <span class="nn">cupy</span> <span class="kn">import</span> <span class="n">matmul</span>   <span class="k">as</span> <span class="n">_matmul</span>
<span class="kn">from</span> <span class="nn">cupy</span> <span class="kn">import</span> <span class="n">multiply</span> <span class="k">as</span> <span class="n">_multiply</span>
<span class="kn">from</span> <span class="nn">cupy</span> <span class="kn">import</span> <span class="n">zeros</span>    <span class="k">as</span> <span class="n">_zeros</span>

<span class="c1"># Additional imports for the module</span>
<span class="kn">from</span> <span class="nn">.communicators</span> <span class="kn">import</span> <span class="n">NCCLComm</span>
<span class="kn">from</span> <span class="nn">.comm_utils</span> <span class="kn">import</span> <span class="n">GetTopology</span>
<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">.cupyCuSPARSELib</span>  <span class="kn">import</span> <span class="n">spMM</span> <span class="k">as</span> <span class="n">_spMM</span>
<span class="kn">from</span> <span class="nn">.cupyCuSPARSELib</span>  <span class="kn">import</span> <span class="n">spMat</span><span class="p">,</span> <span class="n">spRandMat</span><span class="p">,</span> <span class="n">spMM</span>
<span class="kn">from</span> <span class="nn">.cupy_utils</span>       <span class="kn">import</span> <span class="n">pin_memory</span> <span class="k">as</span> <span class="n">_pin_mem</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span><span class="p">,</span> <span class="n">csc_matrix</span><span class="p">,</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">dia_matrix</span><span class="p">,</span> <span class="n">issparse</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">data_operations</span>


<span class="c1"># Defining some constants for the module</span>
<span class="n">PRECISIONS</span>  <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;float32&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="s1">&#39;int16&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="s1">&#39;int32&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span><span class="s1">&#39;int64&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">}</span>
<span class="n">WORKLOADS</span>   <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nmf&#39;</span><span class="p">:</span><span class="s1">&#39;NMF&#39;</span><span class="p">,</span> <span class="s1">&#39;nmfk&#39;</span><span class="p">:</span><span class="s1">&#39;NMFk&#39;</span><span class="p">,</span> <span class="s1">&#39;bench&#39;</span><span class="p">:</span><span class="s1">&#39;BENCHMARK&#39;</span> <span class="p">}</span>
<span class="n">NMF_NORMS</span>   <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fro&#39;</span><span class="p">:</span><span class="s1">&#39;FROBENUS&#39;</span><span class="p">,</span> <span class="s1">&#39;kl&#39;</span><span class="p">:</span><span class="s1">&#39;KL&#39;</span><span class="p">}</span>
<span class="n">NMF_METHODS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;mu&#39;</span><span class="p">:</span><span class="s1">&#39;Multiplicative Update&#39;</span><span class="p">}</span>
<span class="n">NMF_INITS</span>   <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rand&#39;</span><span class="p">:</span><span class="s1">&#39;RANDOM&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span><span class="s1">&#39;RANDOM&#39;</span><span class="p">,</span> <span class="s1">&#39;nnsvd&#39;</span><span class="p">:</span><span class="s1">&#39;Non-Negative SVD&#39;</span><span class="p">,</span> <span class="s1">&#39;svd&#39;</span><span class="p">:</span><span class="s1">&#39;SVD&#39;</span><span class="p">}</span>

<span class="c1"># Utility function to raise an exception for unsupported operations</span>
<div class="viewcode-block" id="noSupportFor"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.noSupportFor">[docs]</a><span class="k">def</span> <span class="nf">noSupportFor</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not yet supported on GPU&quot;</span><span class="p">)</span></div>


<span class="c1"># The main class to perform NMF on GPU</span>
<div class="viewcode-block" id="cudaNMF"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF">[docs]</a><span class="k">class</span> <span class="nc">cudaNMF</span><span class="p">():</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A_ij</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Initialize the cudaNMF class.</span>

<span class="sd">         Parameters</span>
<span class="sd">         ----------</span>
<span class="sd">         A_ij : array-like</span>
<span class="sd">             The matrix to be factorized.</span>
<span class="sd">         k : int</span>
<span class="sd">             Rank of the factorization.</span>
<span class="sd">         params : dict</span>
<span class="sd">             Configuration parameters for NMF.</span>
<span class="sd">         factors : array-like, optional</span>
<span class="sd">             Initial guess for the factors.</span>
<span class="sd">         save_factors : bool, optional</span>
<span class="sd">             Whether to save factors or not.</span>

<span class="sd">         &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span>          <span class="o">=</span> <span class="n">A_ij</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span>        <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span>             <span class="o">=</span> <span class="n">k</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">factors</span>       <span class="o">=</span> <span class="n">factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_factors</span>  <span class="o">=</span> <span class="n">save_factors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">VRBZ</span>          <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">verbose</span>
        <span class="k">try</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span>       <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">comm1</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">149</span><span class="o">*</span><span class="s1">&#39;#&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]                                          --[</span><span class="si">{}</span><span class="s2">  comm </span><span class="si">{}</span><span class="s2">]--&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">red</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">),</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;MPI&#39;</span><span class="p">),</span> <span class="n">red</span><span class="p">(</span><span class="s2">&quot;NOT FOUND&quot;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span>       <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">149</span><span class="o">*</span><span class="s1">&#39;#&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="p">(</span><span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]                                               --[</span><span class="si">{}</span><span class="s2">  comm built </span><span class="si">{}</span><span class="s2">]--&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">green</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">),</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;MPI&#39;</span><span class="p">),</span> <span class="n">green</span><span class="p">(</span><span class="s2">&quot;OK&quot;</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>        <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">topo_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_m</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">local_n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">p_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">p_c</span>
        <span class="c1">#[1] Identify distributed system&#39;s topology</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NCCL_COMM_BUILT</span>        <span class="o">=</span>  <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identify_distributed_system_compute_topology</span><span class="p">()</span>
        <span class="c1">#[2] Identify Global compute grid parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_op</span> <span class="o">=</span> <span class="n">data_operations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_op</span><span class="o">.</span><span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GPU_GRID_BUILT</span>         <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#[3] Identify A matrix partition method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">find_optimat_partition_strategy</span><span class="p">()</span>
        <span class="c1">#[4] Build GPU communication COMM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkGPUContext</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buildSubCommunicators</span><span class="p">()</span>
        <span class="n">METHOD</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;NMF_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span><span class="si">}</span><span class="s2">_cuda&quot;</span>
        <span class="c1">#[5] Check format (dense/sparse) of A matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SPARSE_BUFF_PINNED_MEM_PARAMS_CONFIGURED</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_A_matrix_format</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
            <span class="n">METHOD</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;sparse_</span><span class="si">{</span><span class="n">METHOD</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">METHOD</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;dense_</span><span class="si">{</span><span class="n">METHOD</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NMFMethod</span> <span class="o">=</span> <span class="n">METHOD</span>
        <span class="c1">#[6] Identifiy arrays that will be cached on GPU</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">A_is_batched</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_is_cached</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">W_is_cached</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">H_is_cached</span>  <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">gpu_arrays</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">GPU_arrays</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[!][CACHING] GPU arrays unspecified&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[!][CACHING] Assuming A, W, and H are cached on GPU&quot;</span><span class="p">)</span>
            <span class="n">gpu_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpu_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">automatic_gpu_array_selection</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ARR</span> <span class="ow">in</span> <span class="n">gpu_arrays</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">ARR</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">arr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;optim&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">automatic_gpu_array_selection</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gpu_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">automatic_gpu_array_selection</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;COMING SOON&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] Automatic/Optimal GPU array selection is </span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;Not yet supported&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#[7] Build GPU MEM grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">nBatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">batchQeueSize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qs</span>                   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SQ</span>                   <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MAXSTREAMS</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">MAXSTREAMS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">GPU_GRID_BUILT</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gpu_grid_params</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span>        <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">COL_BATCHING_AXIS</span>    <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span>    <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">find_optimal_baching_axis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_batching_params</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">NMFMethod</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_BATCHED&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">NMFMethod</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache_A_on_device</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_A_info</span><span class="p">()</span>
        <span class="c1">#[8] Prepare events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">GB</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TB</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">GB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;NMF&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;W_up&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;H_up&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> 
                   <span class="s2">&quot;allRed_XHT&quot;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;allRed_WHHT&quot;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="s1">&#39;allRed_WTX&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;allRed_WTWH&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="s1">&#39;allRed_WTW&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;allRed_HHT&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="s1">&#39;H2D_A&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;H2D_H&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;H2D_W&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="s1">&#39;D2H_A&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;D2H_H&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;D2H_W&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span>
                   <span class="s1">&#39;units&#39;</span><span class="p">:</span><span class="s1">&#39;[ms]&#39;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span>                             <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>                    <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span>                      <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_s&#39;</span><span class="p">]</span>                    <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_e&#39;</span><span class="p">]</span>                    <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;d2h_s&#39;</span><span class="p">]</span>                    <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;d2h_e&#39;</span><span class="p">]</span>                    <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span>                 <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span>                 <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">]</span>                <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span>                  <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="c1">#[9] Build random generation initial state seeds # This is used so that cofactors are initialized</span>
        <span class="c1">#    locally and therefor avoiding broadcat communications</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">iter_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">end_k</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">end_k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">iter_seeds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">iter_seeds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">iter_seeds</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_seeds</span> <span class="o">=</span> <span class="n">iter_seeds</span>
        <span class="c1">#[10] Configure Pinned Memory management Pool</span>
        <span class="c1">#self.PINNEDMEMPOOL  = cp.cuda.PinnedMemoryPool()</span>
        <span class="c1">#cp.cuda.set_pinned_memory_allocator(self.PINNEDMEMPOOL.malloc)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span>        <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_default_memory_pool</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PINNEDMEMPOOL</span>  <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">PinnedMemoryPool</span><span class="p">()</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">set_pinned_memory_allocator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PINNEDMEMPOOL</span><span class="o">.</span><span class="n">malloc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span>        <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_default_memory_pool</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">PINNEDMEMPOOL</span>  <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">get_default_pinned_memory_pool</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">()</span>
        <span class="c1">#[11] Build Qeues of CUDA STREAMS for Async copies management</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">STREAMS</span>        <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span>         <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">FREE_STREAM</span>    <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">REDUCE_STREAM</span>  <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MAXSTREAMS</span>     <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAXSTREAMS</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MAXSTREAMS</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;s</span><span class="si">%04d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">STREAMS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>    <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FREE_STREAM</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>


<div class="viewcode-block" id="cudaNMF.log"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">msg</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints a log message.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        msg : str</span>
<span class="sd">            The message to be logged.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span></div>


<div class="viewcode-block" id="cudaNMF.isCupyObject"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.isCupyObject">[docs]</a>    <span class="k">def</span> <span class="nf">isCupyObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the input object is a Cupy object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : object</span>
<span class="sd">            The object to be checked.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if x is a Cupy object, False otherwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span></div>


<div class="viewcode-block" id="cudaNMF.getArrayType"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.getArrayType">[docs]</a>    <span class="k">def</span> <span class="nf">getArrayType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the type of the array (CPU/GPU, dense/sparse, etc.).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            The array whose type needs to be determined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Type of the array (e.g., &quot;CPU_DENSE&quot;, &quot;GPU_SPARSE&quot;).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">T</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;LIST[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getObjectType</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">T</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;CPU_DENSE&quot;</span>
        <span class="k">elif</span> <span class="n">T</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;GPU_DENSE&quot;</span>
        <span class="k">elif</span> <span class="n">T</span> <span class="ow">in</span> <span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;CPU_SPARSE&quot;</span>
        <span class="k">elif</span> <span class="n">T</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cupyx</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">,</span> <span class="n">cupyx</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">,</span> <span class="n">cupyx</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">]:</span>
            <span class="k">return</span> <span class="s2">&quot;GPU_SPARSE&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;UNKNOWN&quot;</span></div>


<div class="viewcode-block" id="cudaNMF.identify_distributed_system_compute_topology"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.identify_distributed_system_compute_topology">[docs]</a>    <span class="k">def</span> <span class="nf">identify_distributed_system_compute_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identifies the distributed system&#39;s compute topology and sets up the necessary</span>
<span class="sd">        attributes related to topology.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">GetTopology</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">VRBZ</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_topology</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">global_uID</span> <span class="o">=</span> <span class="n">nccl</span><span class="o">.</span><span class="n">get_unique_id</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">global_uID</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_uID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">global_uID</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">myHost</span>                 <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">myHost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrank</span>                  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">lrank</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nGPU_local</span>             <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">nGPU_local</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span>                  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">topology</span><span class="p">[</span><span class="s1">&#39;nGPUs&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="cudaNMF.compute_global_dim"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.compute_global_dim">[docs]</a>    <span class="k">def</span> <span class="nf">compute_global_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">##[IDB]: This is needed here</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes global dimensions m and n from given chunk sizes for any grid configuration&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_r</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_c</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_m</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_c</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_r</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_m</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_m</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_m</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">global_n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">global_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span></div>


<div class="viewcode-block" id="cudaNMF.checkGPUContext"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.checkGPUContext">[docs]</a>    <span class="k">def</span> <span class="nf">checkGPUContext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if the current instance is operating within a GPU context and sets up</span>
<span class="sd">        GPU-related attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrank</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nGPU_local</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IN_GPU_CONTEXT</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lID</span>            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrank</span>              <span class="c1"># Local  GPU ID</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gID</span>            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">gID</span>       <span class="c1"># Global GPU ID</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Device</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span><span class="o">.</span><span class="n">use</span><span class="p">()</span>
            <span class="c1">#self.device         = cp.cuda.Device()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cudaDevice</span>     <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">getDevice</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">VRBZ</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;I am using &lt;Global Device</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gID</span><span class="si">}</span><span class="s2">&gt; | &lt;Local Device</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cudaDevice</span><span class="si">}</span><span class="s2">&gt; on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">myHost</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IN_GPU_CONTEXT</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lID</span>            <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gID</span>            <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">VRBZ</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;I am not using CUDA&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nccl_group_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IN_GPU_CONTEXT</span><span class="p">),</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[+][NCCL] GROUP size = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nccl_group_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="cudaNMF.check_A_matrix_format"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.check_A_matrix_format">[docs]</a>    <span class="k">def</span> <span class="nf">check_A_matrix_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks the format of matrix A, decides if it&#39;s sparse or dense, and sets the</span>
<span class="sd">        necessary attributes related to the matrix&#39;s format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">densify_A</span><span class="p">:</span>           <span class="c1"># Dense A and Array format</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> <span class="c1"># Converting to dense for now (Fix Not Efficient)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_in_sparse_format</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span>        <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>                               <span class="c1"># Sparse A and sparse format</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_in_sparse_format</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span>        <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_nnz</span>              <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">nnz</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_density</span>          <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_nnz</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">global_n</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">MM</span> <span class="o">=</span> <span class="n">_spMM</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_in_sparse_format</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_in_sparse_format</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_nnz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_nnz</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_nnz</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">global_n</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_density</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">sparsity_tresh</span><span class="p">:</span>      <span class="c1"># Dense A and Array format</span>
                <span class="c1">#self.NMFMethod = &#39;dense_{}&#39;.format(self.NMFMethod)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">MM</span> <span class="o">=</span> <span class="n">_matmul</span>
            <span class="k">else</span><span class="p">:</span>                                                   <span class="c1"># Dense A and sparse format</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">sparsify_A</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A_in_sparse_format</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">MM</span> <span class="o">=</span> <span class="n">_spMM</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">MM</span> <span class="o">=</span> <span class="n">_matmul</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_DENSE</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span></div>


<div class="viewcode-block" id="cudaNMF.show_A_info"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.show_A_info">[docs]</a>    <span class="k">def</span> <span class="nf">show_A_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs and displays information about matrix A, including dimensions, density,</span>
<span class="sd">        and other related attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] [   </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Local&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">   ] A_ij[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_m</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_n</span><span class="p">)</span><span class="si">}</span><span class="s2">] (</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;GB&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">) built </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] [</span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Distributed&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] A_ij[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_m</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_n</span><span class="p">)</span><span class="si">}</span><span class="s2">] (</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="w"> </span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">global_m</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">global_n</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;GB&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">) built </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  Density         = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">A_density</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">COL_PARTITION</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  Nr = nBatch     = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="si">}</span><span class="s2">   -&gt; Batch Size = m/nBatch = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  Nc = nBatch     = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="si">}</span><span class="s2">   -&gt; Batch Size = n/nBatch = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_chunk</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  Uneven split         -&gt; Last Batch Size       = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">last_chunk</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1">#self.log(f&quot;[{green(&#39;+&#39;)}]    Nc        = nGPUs = {self.grid_Nc} -&gt; J  = n/Nc = {self.grid_J}&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  Batch Qeue size = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">149</span><span class="o">*</span><span class="s1">&#39;#&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;WORKLOAD&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                    :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="n">WORKLOADS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">work_load</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;NMF METHOD&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                  :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="n">NMF_METHODS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;NMF NORM&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                    :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="n">NMF_NORMS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;NMF INIT&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                    :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="n">NMF_INITS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Number of perturbation&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">      :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">perturbations</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Iterations/Perturbation&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">     :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">))</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Range k&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                     :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">start_k</span><span class="p">))</span><span class="si">}</span><span class="s2"> &lt; k &lt; </span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">end_k</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Delta k&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                     :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">step</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Sill Threshold&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">              :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">sill_thr</span><span class="p">))</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;Noise&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                       :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">noise_var</span><span class="p">))</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]  </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;GPU Arrays&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">                  :  </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpu_arrays</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">149</span><span class="o">*</span><span class="s1">&#39;#&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">149</span><span class="o">*</span><span class="s1">&#39;#&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span></div>


<div class="viewcode-block" id="cudaNMF.show_topology"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.show_topology">[docs]</a>    <span class="k">def</span> <span class="nf">show_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Displays information about the system&#39;s topology.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">showTopology</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[+] topo_dim    = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">topo_dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[+] myHost      = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">myHost</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[+] lrank       = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">lrank</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[+] nGPU_local  = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">nGPU_local</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[+] nGPUs       = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">topology</span><span class="p">[</span><span class="s1">&#39;nGPUs&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span></div>


<div class="viewcode-block" id="cudaNMF.buildSubCommunicators"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.buildSubCommunicators">[docs]</a>    <span class="k">def</span> <span class="nf">buildSubCommunicators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rebuildNCCLCOM</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            rebuildNCCLCOM (bool): Flag indicating if NCCL Communicator should be rebuilt.</span>

<span class="sd">        Builds sub-communicators for the distributed system. Optionally rebuilds the NCCL communicator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">IN_GPU_CONTEXT</span><span class="p">:</span>
          <span class="n">color</span> <span class="o">=</span> <span class="mi">55</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">color</span> <span class="o">=</span> <span class="mi">77</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sub_comm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">NCCL_COMM_BUILT</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">rebuildNCCLCOM</span><span class="p">)):</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildNCCLSubCommunicator</span><span class="p">()</span></div>
    

<div class="viewcode-block" id="cudaNMF.buildNCCLSubCommunicator"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.buildNCCLSubCommunicator">[docs]</a>    <span class="k">def</span> <span class="nf">buildNCCLSubCommunicator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the NCCL sub-communicator for GPU context. Sets the related attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">IN_GPU_CONTEXT</span><span class="p">:</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">VRBZ</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[+] Broadcasting NCCL global_UID&quot;</span><span class="p">)</span>
            <span class="n">global_uID</span> <span class="o">=</span> <span class="n">nccl</span><span class="o">.</span><span class="n">get_unique_id</span><span class="p">()</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">global_uID</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">global_uID</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">global_uID</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">VRBZ</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[+] NCCL global_UID received OK&quot;</span><span class="p">)</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span> <span class="o">=</span> <span class="n">NCCLComm</span><span class="p">(</span><span class="n">ndev</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nccl_group_size</span><span class="p">,</span> <span class="n">commId</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">global_uID</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NCCL_COMM_BUILT</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">149</span><span class="o">*</span><span class="s1">&#39;#&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]                                                --[</span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="s1">&#39;NCCL&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2"> comm built </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;OK&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">]--&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">149</span><span class="o">*</span><span class="s1">&#39;#&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span></div>
    

<div class="viewcode-block" id="cudaNMF.get_gpu_grid_params"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.get_gpu_grid_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_gpu_grid_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches or calculates GPU grid parameters based on the current setup.</span>
<span class="sd">        Sets the related attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">GPU_GRID_BUILT</span><span class="p">:</span> <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_loc_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_loc_n</span>      <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">local_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_n</span>    <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">global_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_n</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nnsvd&#39;</span><span class="p">,</span><span class="s1">&#39;svd&#39;</span><span class="p">,</span><span class="s1">&#39;singular&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">COL_PARTITION</span><span class="p">:</span> <span class="c1"># n&gt;m</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_m</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid_q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_n</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid_q</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span></div>



<div class="viewcode-block" id="cudaNMF.cache_A_on_device"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.cache_A_on_device">[docs]</a>    <span class="k">def</span> <span class="nf">cache_A_on_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Caches matrix A on the device for faster access during GPU operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">GPU_GRID_BUILT</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_gpu_grid_params</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">IN_GPU_CONTEXT</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">COL_PARTITION</span><span class="p">:</span>
                    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spMat</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">Format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spMat</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">],</span> <span class="n">Format</span><span class="o">=</span><span class="s1">&#39;csr&#39;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A_is_cached</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="cudaNMF.cache_H_on_device"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.cache_H_on_device">[docs]</a>    <span class="k">def</span> <span class="nf">cache_H_on_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>   <span class="c1"># W.I.P</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method sets the flag indicating that the matrix H is cached on the device.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H_is_cached</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="cudaNMF.cache_W_on_device"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.cache_W_on_device">[docs]</a>    <span class="k">def</span> <span class="nf">cache_W_on_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>   <span class="c1"># W.I,P</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method sets the flag indicating that the matrix W is cached on the device.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">W_is_cached</span> <span class="o">=</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="cudaNMF.find_optimat_partition_strategy"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.find_optimat_partition_strategy">[docs]</a>    <span class="k">def</span> <span class="nf">find_optimat_partition_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method determines the best GPU partitioning strategy based on the provided parameters.</span>
<span class="sd">        It supports partitioning in &#39;row&#39;, &#39;column&#39; or &#39;auto&#39; modes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Attempt to set partition type from parameters; default to &#39;auto&#39; on failure.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">partition_type</span>              <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">gpu_partition</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">partition_type</span>              <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>

        <span class="c1"># Check the partition type and set the GPU_PARTITION attribute accordingly.</span>
        <span class="c1"># Multiple alias names are supported for each partitioning strategy.</span>
        <span class="k">if</span> <span class="n">partition_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;row1&#39;</span><span class="p">,</span> <span class="s1">&#39;1row&#39;</span> <span class="p">,</span><span class="s1">&#39;row_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;1d_row&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span> <span class="o">=</span> <span class="s1">&#39;row_1d&#39;</span>
        <span class="c1"># ... (similar checks for other partition types) ...</span>
        <span class="k">elif</span> <span class="n">partition_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;col&#39;</span><span class="p">,</span> <span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;1col&#39;</span> <span class="p">,</span><span class="s1">&#39;col_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;1d_col&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;column_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;1d_column&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span> <span class="o">=</span> <span class="s1">&#39;col_1d&#39;</span>
        <span class="c1"># If &#39;auto&#39; mode, optimize for grid partition.</span>
        <span class="k">elif</span> <span class="n">partition_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;optim&#39;</span><span class="p">,</span> <span class="s1">&#39;optimal&#39;</span><span class="p">]:</span>
            <span class="c1"># ... (logic to automatically choose the partition type) ...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][PARTION]: GPU_PARTITION is set to </span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
                <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][PARTION]: Optimizing for grid partion ...&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_n</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span> <span class="o">=</span> <span class="s1">&#39;row_1d&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span> <span class="o">=</span> <span class="s1">&#39;col_1d&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][PARTION]: GPU_PARTITION is set to </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[!!] GPU grid partition </span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">gpu_partition</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported. Try </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;row&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Set ROW and COL partition flags based on GPU_PARTITION.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;row_1d&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">COL_PARTITION</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">COL_PARTITION</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ROW_PARTITION</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">COL_PARTITION</span></div>



<div class="viewcode-block" id="cudaNMF.find_optimal_baching_axis"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.find_optimal_baching_axis">[docs]</a>    <span class="k">def</span> <span class="nf">find_optimal_baching_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">batching_axis</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>
        <span class="k">if</span>  <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">,</span> <span class="s1">&#39;row1&#39;</span><span class="p">,</span> <span class="s1">&#39;1row&#39;</span> <span class="p">,</span><span class="s1">&#39;row_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;1d_row&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="o">=</span> <span class="s1">&#39;row_1d&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;col&#39;</span><span class="p">,</span> <span class="s1">&#39;col1&#39;</span><span class="p">,</span> <span class="s1">&#39;1col&#39;</span> <span class="p">,</span><span class="s1">&#39;col_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;1d_col&#39;</span><span class="p">,</span> <span class="s1">&#39;column&#39;</span><span class="p">,</span> <span class="s1">&#39;column_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;1d_column&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="o">=</span> <span class="s1">&#39;col_1d&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;optim&#39;</span><span class="p">,</span> <span class="s1">&#39;optimal&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][BATCHING]: STRATEGY is set to </span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GPU_PARTITION</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
                <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][BATCHING]: Optimizing for BATCHING STRATEGY...&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_loc_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_loc_n</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="o">=</span> <span class="s1">&#39;row_1d&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="o">=</span> <span class="s1">&#39;col_1d&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][BATCHING]: STRATEGY is set to </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[!!] BATCHING STRATEGY </span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">BATCHING_AXIS</span><span class="p">)</span><span class="si">}</span><span class="s2"> is not supported. Try </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;column&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">green</span><span class="p">(</span><span class="s1">&#39;row&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;row_1d&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">COL_BATCHING_AXIS</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span></div>


<div class="viewcode-block" id="cudaNMF.set_batching_params"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.set_batching_params">[docs]</a>    <span class="k">def</span> <span class="nf">set_batching_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>              <span class="c1"># Row-wise batchingn</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>                     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_m</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_chunk</span>                     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_m</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>                         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>  <span class="c1"># min(self.params.IMAX, self.grid_glob_m)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">grid_I</span>                  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Nc</span>          <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">,</span> <span class="mi">1</span>   <span class="c1"># int(self.grid_loc_m/self.grid_I), int(1*self.nGPUs)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span>                         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_n</span>     <span class="c1"># int(self.grid_loc_n/self.grid_Nc)</span>
        <span class="k">else</span><span class="p">:</span>                                   <span class="c1"># Column-wise batching</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>                     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_n</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_chunk</span>                     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_n</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span>                         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>  <span class="c1"># min(self.params.JMAX, self.grid_loc_n)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">grid_J</span>                  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Nc</span>          <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span>    <span class="c1"># 1, int(self.grid_loc_n/self.grid_J)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>                         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_m</span>     <span class="c1"># int(self.grid_loc_m/self.grid_Nr)</span></div>


<div class="viewcode-block" id="cudaNMF.get_managed_stream_queue"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.get_managed_stream_queue">[docs]</a>    <span class="k">def</span> <span class="nf">get_managed_stream_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes and returns a dictionary for managing stream queues for GPU operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SQ</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;Queue&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">)</span>
        <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;READY&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">#[1] En-queue working streams and set their states to ready to work</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qs</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;READY&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
            <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;Queue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;REDUCE&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
        <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;COMPLETED&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">SQ</span></div>


<div class="viewcode-block" id="cudaNMF.configure_sparse_buffers_pinned_mem_params"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.configure_sparse_buffers_pinned_mem_params">[docs]</a>    <span class="k">def</span> <span class="nf">configure_sparse_buffers_pinned_mem_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configures the parameters for pinned memory buffers when dealing with sparse matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPARSE_BUFF_PINNED_MEM_PARAMS_CONFIGURED</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">BATCHING_AXIS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;[!] PINNED MEM BUFFERS are used only for BATCHING&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">,</span> <span class="s2">&quot;[!] SPARSE PINNED MEM BUFFERS are used only for BATCHING A in SPARSE FORMAT&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buff_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buff_ptr</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dat&#39;</span><span class="p">:[],</span><span class="s1">&#39;idx&#39;</span><span class="p">:[],</span><span class="s1">&#39;ptr&#39;</span><span class="p">:[]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
            <span class="c1">#if self.ROW_PARTITION:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>
                <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;ptr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">indptr</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span> <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span>  <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span>  <span class="o">=</span>  <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">indptr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Col Partition</span>
                <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;ptr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">))</span>
            <span class="c1">#print(&quot;[b%04d] lenData, lenIdx, lenPtr = {},{},{}&quot;.format(self.sparseData_max_vect_size, self.sparseIdx_max_vect_size, self.sparsePtr_max_vect_size) %b)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SPARSE_BUFF_PINNED_MEM_PARAMS_CONFIGURED</span> <span class="o">=</span> <span class="kc">True</span></div>




<div class="viewcode-block" id="cudaNMF.allocate_sparse_batch_buffers"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.allocate_sparse_batch_buffers">[docs]</a>    <span class="k">def</span> <span class="nf">allocate_sparse_batch_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allocate memory for sparse batch buffers.</span>

<span class="sd">        This method configures memory parameters if not already set. Based on the specified</span>
<span class="sd">        batching axis, it initializes the appropriate buffers to store the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if memory parameters for sparse buffers are configured</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPARSE_BUFF_PINNED_MEM_PARAMS_CONFIGURED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">configure_sparse_buffers_pinned_mem_params</span><span class="p">()</span>

        <span class="c1"># Allocate memory based on column batching axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">COL_BATCHING_AXIS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buff_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buff_ptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># ROW_BATCHING_AXIS</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buff_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buff_ptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span></div>


<div class="viewcode-block" id="cudaNMF.allocate_dense_batch_buffers"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.allocate_dense_batch_buffers">[docs]</a>    <span class="k">def</span> <span class="nf">allocate_dense_batch_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allocate memory for dense batch buffers.</span>

<span class="sd">        Based on the specified batching axis, this method initializes the appropriate</span>
<span class="sd">        buffers to store dense data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Allocate memory based on column batching axis</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">COL_BATCHING_AXIS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                <span class="c1">#self.X_d.append(cp.empty((self.grid_loc_m, self.batch_size), dtype=self.A_ij.dtype))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># ROW_BATCHING_AXIS</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                <span class="c1">#self.X_d.append(cp.empty((self.batch_size, self.grid_loc_n), dtype=self.A_ij.dtype))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span></div>


<div class="viewcode-block" id="cudaNMF.allocate_gpu_batch_buffers"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.allocate_gpu_batch_buffers">[docs]</a>    <span class="k">def</span> <span class="nf">allocate_gpu_batch_buffers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allocate memory for batch buffers on GPU.</span>

<span class="sd">        Depending on whether the data is sparse or dense, it calls the appropriate</span>
<span class="sd">        method to initialize the buffers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if the data is batched</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allocate_sparse_batch_buffers</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allocate_dense_batch_buffers</span><span class="p">()</span></div>

<div class="viewcode-block" id="cudaNMF.showMemStats"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.showMemStats">[docs]</a>    <span class="k">def</span> <span class="nf">showMemStats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display memory statistics.</span>

<span class="sd">        It logs information about used and available memory, including details about</span>
<span class="sd">        the pinned memory pool.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            msg (str): Optional message to include in the log.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Only process with rank 0 displays the memory stats</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][MEM INFO] </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
            <span class="c1"># Log info based on whether the data is batched or not</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][MEM INFO] </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
                <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][PINNEDMEM]: FREE BLOCKS = </span><span class="si">{</span><span class="w"> </span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PINNEDMEMPOOL</span><span class="o">.</span><span class="n">n_free_blocks</span><span class="p">())</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][MEMPOOL]: USED = </span><span class="si">{</span><span class="w"> </span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">used_bytes</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">GB</span><span class="p">)</span><span class="si">}</span><span class="s2"> GB || TOTAL = </span><span class="si">{</span><span class="w"> </span><span class="n">red</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">GB</span><span class="p">)</span><span class="w"> </span><span class="si">}</span><span class="s2"> GB&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
                <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][PINNEDMEM]: FREE BLOCKS = </span><span class="si">{</span><span class="w"> </span><span class="n">amber</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PINNEDMEMPOOL</span><span class="o">.</span><span class="n">n_free_blocks</span><span class="p">())</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span></div>

<div class="viewcode-block" id="cudaNMF.sampleA"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.sampleA">[docs]</a>    <span class="k">def</span> <span class="nf">sampleA</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">noise_var</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples matrix A based on a specified method and noise variance.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            - noise_var (float): Variance of the noise.</span>
<span class="sd">            - method (str): Sampling method, either &#39;uniform&#39; or &#39;poisson&#39;.</span>
<span class="sd">            - seed (int, optional): Random seed for reproducibility.</span>

<span class="sd">        Raises:</span>
<span class="sd">            - Exception if an unsupported sampling method is provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">=</span> <span class="n">noise_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_method</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">randM</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_method</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poisson</span><span class="p">()</span></div>


<div class="viewcode-block" id="cudaNMF.randM"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.randM">[docs]</a>    <span class="k">def</span> <span class="nf">randM</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perturbs the elements of X by multiplying them with a uniform random number in the range (1-epsilon, 1+epsilon).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if X_per has been initialized, if not, initialize the arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_ptr</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="c1">#self.showMemStats(msg = &quot; RandM() 0&quot;)</span>

        <span class="c1"># Free up memory blocks in the memory pool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
        <span class="c1">#self.showMemStats(msg = &quot; RandM() MEMPOOL Freed OK&quot;)</span>

        <span class="c1"># Get the max available memory in bytes</span>
        <span class="n">MAXMEM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span> <span class="c1">#CPU Array</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>
                        <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Col Axis</span>
                        <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">+</span> <span class="mf">1.0</span>
                    <span class="n">X</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">M</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span><span class="p">:</span> <span class="c1"># Initialize sparse array pinned mem buffers</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pin_mem</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">))))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pin_mem</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">))))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_ptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pin_mem</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="o">.</span><span class="n">dtype</span><span class="p">))))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#print(f&quot;Before : type(X_per) = {self.X_per[b].dtype}&quot;)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseData_max_vect_size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_idx</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparseIdx_max_vect_size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_ptr</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sparsePtr_max_vect_size</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">indptr</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                        <span class="c1">#print(f&quot;Afterpe : type(X_per) = {self.X_per[b].dtype}&quot;)</span>

                <span class="k">else</span><span class="p">:</span> <span class="c1"># A in Dense</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>
                        <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="n">M</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">+</span> <span class="mf">1.0</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pin_mem</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">M</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">M</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1"># Row Axis</span>
                        <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="n">M</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">+</span> <span class="mf">1.0</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pin_mem</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">],</span> <span class="n">M</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">],</span> <span class="n">M</span><span class="p">)</span>

        <span class="k">else</span> <span class="p">:</span> <span class="c1">#GPU Array</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                    <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="mf">1.0</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">*</span> <span class="n">M</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">+</span> <span class="mf">1.0</span>
                    <span class="n">X</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="n">M</span>
                    <span class="c1">#self.X_per.append(X)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># A in Dense</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; RandM() BEFORE X_per init  b</span><span class="si">%04d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
                    <span class="n">MAXMEM</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MAXMEM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; RandM() AFTER X_per init 1  b</span><span class="si">%04d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">MAXMEM</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MAXMEM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; RandM() AFTER X_per set 1  b</span><span class="si">%04d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">MAXMEM</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MAXMEM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_var</span> <span class="o">+</span> <span class="mf">1.0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; RandM() X_per init OK  b</span><span class="si">%04d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][MEMPOOL]: randM(): MEM Peak = </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="n">MAXMEM</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">GB</span><span class="p">)</span><span class="si">}</span><span class="s2"> GB&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per_initialized</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="cudaNMF.init_factors"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.init_factors">[docs]</a>    <span class="k">def</span> <span class="nf">init_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes NMF factor matrices W and H based on the selected initialization method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Random initialization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">init</span> <span class="o">==</span> <span class="s1">&#39;rand&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span><span class="o">==</span><span class="s1">&#39;2d&#39;</span><span class="p">:</span>
                <span class="c1">#raise Exception(f&quot;[{red(&#39;!!&#39;)}] 2D topology is not yet supported on GPU&quot;)</span>
                <span class="n">noSupport</span><span class="p">(</span><span class="s2">&quot;2D topology&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;1d&#39;</span><span class="p">]:</span>
                <span class="n">rng_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_seeds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">])</span>
                <span class="n">rng_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_seeds</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">])</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span>     <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>               <span class="c1"># H   [k, J]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">H_is_cached</span> <span class="o">=</span>  <span class="kc">True</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>  <span class="c1"># W is distributed, H is replicate on Hostd</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">W_h</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pin_mem</span><span class="p">(</span><span class="n">rng_h</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">W_is_cached</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">rng_d</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># W_h [m, k]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">W_is_cached</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># COL_BATCHING_AXIS:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>                   <span class="c1"># W_d [I, k]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">W_is_cached</span> <span class="o">=</span>  <span class="kc">True</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>  <span class="c1"># H is distributed, W is replicate on Hostd</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_pin_mem</span><span class="p">(</span><span class="n">rng_h</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">H_is_cached</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">rng_d</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># W_h [m, k]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">H_is_cached</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># NNSVD-based initialization</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">init</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nnsvd&#39;</span><span class="p">,</span><span class="s1">&#39;svd&#39;</span><span class="p">,</span><span class="s1">&#39;singular&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span> <span class="o">==</span> <span class="s1">&#39;1d&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">AA</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">AA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">AA</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_L</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">svdSoFar</span>      <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnsvd</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span> <span class="o">==</span> <span class="s1">&#39;2d&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;NNSVD init only available for 1D topology, please try with 1d topo.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Raise an error if an unsupported initialization method is chosen</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] Only Random and nnsvd init is supported on GPU&quot;</span><span class="p">)</span></div>




<div class="viewcode-block" id="cudaNMF.normalize_features"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.normalize_features">[docs]</a>    <span class="k">def</span> <span class="nf">normalize_features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalizes the NMF factor matrices W and H.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If A is batched</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span> <span class="c1"># W.I.P</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">COL_PARTITION</span><span class="p">:</span> <span class="c1"># W.I.P</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">Wall_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">p_r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">Wall_norm</span><span class="p">,</span> <span class="n">Wall_norm</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="o">/=</span> <span class="n">Wall_norm</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span> <span class="o">*=</span>  <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">Wall_norm</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  

        <span class="k">else</span><span class="p">:</span> <span class="c1"># If A is not batched</span>
            <span class="n">Wall_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span> <span class="o">==</span> <span class="s1">&#39;2d&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] 2D topology is not yet supported on GPU&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span> <span class="o">==</span> <span class="s1">&#39;1d&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">p_r</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">Wall_norm</span><span class="p">,</span> <span class="n">Wall_norm</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] Topology </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span><span class="si">}</span><span class="s2">is not yet supported&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">/=</span> <span class="n">Wall_norm</span><span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">*=</span> <span class="n">Wall_norm</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="cudaNMF.relative_err"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.relative_err">[docs]</a>    <span class="k">def</span> <span class="nf">relative_err</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the relative reconstruction error of the NMF decomposition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check topology and raise an error for unsupported topologies</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topo_dim</span> <span class="o">==</span> <span class="s1">&#39;2d&#39;</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] 2D topology is not yet supported on GPU&quot;</span><span class="p">)</span>
        <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># Get the max available memory in bytes</span>
        <span class="n">MAXMEM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span>

        <span class="c1"># Compute the error for batched CPU arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span> <span class="c1">#CPU Array</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span> <span class="c1"># ROW AXIS</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">)</span> <span class="c1"># Download H</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>                  <span class="c1"># COL AXIS</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">W_h</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">)</span> <span class="c1"># Downlod W</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="c1">#err += np.square( self.X_per[b].toarray() - (self.W_h @ self.H_h[b]) ).sum()</span>
                        <span class="n">err</span> <span class="o">+=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">glob_norm_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>     <span class="c1"># Compute the error for GPU arrays</span>
            <span class="c1">#self.showMemStats(msg = &quot; relative_err() STARTING BATCHES&quot;)</span>
            <span class="n">MAXMEM</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MAXMEM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span> <span class="c1"># Row Partition</span>
                    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span>     <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">))</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>

                        <span class="n">err</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">))</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                        <span class="n">MAXMEM</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">MAXMEM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">total_bytes</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>

                <span class="k">else</span><span class="p">:</span>                  <span class="c1"># Col Partition</span>
                    <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span>     <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]))</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]))</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">glob_norm_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_d</span><span class="p">)</span>
            <span class="c1">#self.glob_norm_A = self.dist_norm(self.X_per)</span>
            <span class="c1">#del err</span>
        <span class="n">err</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">glob_norm_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recon_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob_norm_err</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">glob_norm_A</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">amber</span><span class="p">(</span><span class="s1">&#39;!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">][MEMPOOL]: relative_err(): MEM Peak = </span><span class="si">{</span><span class="n">blue</span><span class="p">(</span><span class="n">MAXMEM</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">GB</span><span class="p">)</span><span class="si">}</span><span class="s2"> GB&quot;</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span> <span class="n">lrank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lrank</span><span class="p">)</span> </div>

<div class="viewcode-block" id="cudaNMF.dist_norm"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.dist_norm">[docs]</a>    <span class="k">def</span> <span class="nf">dist_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">proc</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;fro&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the distributed norm of an array.</span>

<span class="sd">        Args:</span>
<span class="sd">        - X (list/array): The input array or list of arrays.</span>
<span class="sd">        - proc (int, optional): Processor ID. Default is -1.</span>
<span class="sd">        - norm (str, optional): Type of matrix norm. Default is &#39;fro&#39; (Frobenius norm).</span>
<span class="sd">        - axis (optional): Axis for norm computation. Default is None.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - float: The computed distributed norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If X is a list, this is a batched computation.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">]:</span> <span class="c1"># BACHED</span>
            <span class="n">array_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getArrayType</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
            <span class="n">N</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">device</span><span class="p">,</span> <span class="n">density</span> <span class="o">=</span> <span class="n">array_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;[!][dist_norm()] UNABLE TO IDENTIFY ARRAY OBJECT TYPE </span><span class="si">{}</span><span class="s1">!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array_type</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">device</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;CPU&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;DENSE&#39;</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span> <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SPARSE&#39;</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span> <span class="n">err</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;[!][dist_norm()] UNABLE TO IDENTIFY ARRAY OBJECT TYPE </span><span class="si">{}</span><span class="s1">!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array_type</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">device</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;GPU&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;DENSE&#39;</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span> <span class="n">err</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SPARSE&#39;</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span> <span class="n">err</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;[!][dist_norm()] UNABLE TO IDENTIFY ARRAY OBJECT TYPE </span><span class="si">{}</span><span class="s1">!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array_type</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;[!][dist_norm()] UNABLE TO IDENTIFY ARRAY OBJECT TYPE </span><span class="si">{}</span><span class="s1">!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array_type</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>                <span class="c1"># If X is not a list, this is a non-batched computation.</span>
            <span class="n">array_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getArrayType</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">device</span><span class="p">,</span> <span class="n">density</span> <span class="o">=</span> <span class="n">array_type</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;[!][dist_norm()] UNABLE TO IDENTIFY ARRAY OBJECT TYPE </span><span class="si">{}</span><span class="s1">!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array_type</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">device</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;CPU&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;DENSE&#39;</span><span class="p">]:</span>
                    <span class="n">err</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SPARSE&#39;</span><span class="p">]:</span>
                    <span class="n">err</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">device</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;GPU&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;DENSE&#39;</span><span class="p">]:</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">density</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SPARSE&#39;</span><span class="p">]:</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;[!][dist_norm()] UNABLE TO IDENTIFY ARRAY OBJECT TYPE </span><span class="si">{}</span><span class="s1">!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array_type</span><span class="p">))</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;[!][dist_norm()] UNABLE TO IDENTIFY ARRAY OBJECT TYPE </span><span class="si">{}</span><span class="s1">!!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">array_type</span><span class="p">))</span>

        <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">err</span><span class="p">)</span></div>


<div class="viewcode-block" id="cudaNMF.fit"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;W&#39;</span><span class="p">,</span><span class="s1">&#39;H&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fits the NMF model based on provided parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">        - factors (list, optional): Initial factor matrices. Default is None.</span>
<span class="sd">        - save_factors (bool, optional): Flag to decide whether to save factor matrices. Default is False.</span>
<span class="sd">        - rtrn (list, optional): List of matrix names to return. Default is [&#39;W&#39;,&#39;H&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">        - tuple: Factor matrices and meta information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;FRO&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;MU&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Fro_MU_update</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="n">save_factors</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="n">rtrn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Not a valid method: Choose (mu)&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;KL&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;MU&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">KL_MU_update</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="n">save_factors</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="n">rtrn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Not a valid method: Choose (mu)&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Not a valid norm: Choose (fro/kl)&#39;</span><span class="p">)</span>
        <span class="c1">#return self.W_i, self.H_j</span>
        <span class="n">metha</span>        <span class="o">=</span> <span class="p">{}</span>
        <span class="n">metha</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">metha</span><span class="p">[</span><span class="s1">&#39;err&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recon_err</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">),</span> <span class="n">metha</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span><span class="p">,</span> <span class="n">metha</span>
            <span class="c1">#return self.W_h, self.H_h, self.recon_err</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">),</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">),</span> <span class="n">metha</span> <span class="c1">#self.recon_err.get()</span></div>


<div class="viewcode-block" id="cudaNMF.Fro_MU_update"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.Fro_MU_update">[docs]</a>    <span class="k">def</span> <span class="nf">Fro_MU_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;W&#39;</span><span class="p">,</span><span class="s1">&#39;H&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Performs updates for NMF using the Frobenius norm and MU optimization method.</span>

<span class="sd">        Args:</span>
<span class="sd">        - factors (list, optional): Initial factor matrices. Default is None.</span>
<span class="sd">        - save_factors (bool, optional): Flag to decide whether to save factor matrices. Default is False.</span>
<span class="sd">        - rtrn (list, optional): List of matrix names to return. Default is [&#39;W&#39;,&#39;H&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">        - None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Memory management and initialization steps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; Fro_MU_update() 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
        <span class="c1">#self.showMemStats(msg = &quot; Fro_MU_update() MEMPOOL Freed OK&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">PINNEDMEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
        <span class="c1"># If the matrix is batched, perform the updates using the appropriate method based on partitioning axis.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span> <span class="c1"># BATCHED CPU -&gt; GPU</span>
            <span class="k">if</span>   <span class="bp">self</span><span class="o">.</span><span class="n">COL_BATCHING_AXIS</span><span class="p">:</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">FroNMF_1D_row</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="n">save_factors</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="n">rtrn</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>
                <span class="c1">#self.FroNMF_1D_col(factors=factors, save_factors=save_factors, rtrn=rtrn)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FroNMF_1D_row_batched</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="n">save_factors</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="n">rtrn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] Grid Partition UNDEFINED!! &quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>                 <span class="c1"># LOCAL BATCHING on GPU Mem</span>
            <span class="k">if</span>  <span class="bp">self</span><span class="o">.</span><span class="n">COL_BATCHING_AXIS</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FroNMF_1D_col_partion</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="n">save_factors</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="n">rtrn</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ROW_BATCHING_AXIS</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">FroNMF_1D_row_partion</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="n">factors</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="n">save_factors</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="n">rtrn</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">red</span><span class="p">(</span><span class="s1">&#39;!!&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">] Grid Partition UNDEFINED!! &quot;</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="cudaNMF.FroNMF_1D_col_partion"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.FroNMF_1D_col_partion">[docs]</a>    <span class="k">def</span> <span class="nf">FroNMF_1D_col_partion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1">#W.I.P</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Performs NMF on 1D column partitioned data using the Frobenius norm.</span>

<span class="sd">        Args:</span>
<span class="sd">        - factors (list, optional): Initial factor matrices. Default is None.</span>
<span class="sd">        - save_factors (bool, optional): Flag to decide whether to save factor matrices. Default is False.</span>
<span class="sd">        - rtrn (bool, optional): Flag to decide whether to return factor matrices. Default is False.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#[1] Initialize perturbed cofactors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_factors</span><span class="p">()</span>
        <span class="c1">#[2] Initialiaze different accumulators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_XHT&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WHHT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">):</span>
            <span class="c1">#[3] Initialize iteration Accumulators</span>
            <span class="n">dt_w</span><span class="p">,</span> <span class="n">dt_h</span><span class="p">,</span> <span class="n">dt_reduce1</span><span class="p">,</span> <span class="n">dt_reduce2</span>   <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
            <span class="n">WT</span>   <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="o">.</span><span class="n">T</span>                                                   <span class="c1"># [m, k].T        -&gt; WT   [k, m]</span>
            <span class="n">WTW</span>  <span class="o">=</span>  <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">)</span>                                        <span class="c1"># [k, m] @ [m, k] -&gt; WTW  [k, k]</span>
            <span class="n">WHHT</span> <span class="o">=</span> <span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>     <span class="c1"># WHHT [m, k] # ACCUMULATOR for W@H@H.T</span>
            <span class="n">XHT</span> <span class="o">=</span> <span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>      <span class="c1"># XHT  [m, k] # ACCUMULATOR for X@H.T</span>
            <span class="c1">#[4] Strart local batching</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                <span class="c1">#[5]////////////////////////////  (H update)&gt; ////////////////////////////////////////////////////////</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="n">WTWH</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WTW</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>           <span class="c1"># [k, k] @ [k, b] -&gt; WTWH [k, b]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                    <span class="n">WTX</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># ([m, b].T @ [m, k]).T -&gt; [b, k].T -&gt;  WTX [k, b]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">WTX</span>  <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>                        <span class="c1"># [k, m] @ [m, b] -&gt; XHT  [k, b]</span>
                <span class="n">WTX</span> <span class="o">=</span> <span class="n">_multiply</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])</span>                     <span class="c1"># [k, b] * [k, b] -&gt; HWTX [k, b]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTWH</span><span class="p">)</span>                      <span class="c1"># [k, b] / [k, b] -&gt; H    [k, b]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="c1">#del  WTWH, WTX</span>
                <span class="c1">#self.MEMPOOL.free_all_blocks()</span>
                <span class="n">dt_h</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
                <span class="c1">#[6]////////////////////////////  (W update)&gt; ////////////////////////////////////////////////////////</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">W_update</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="n">HT</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>                                    <span class="c1"># [k, b].T        -&gt; HT   [b, k]</span>
                    <span class="n">HHT</span>  <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">],</span> <span class="n">HT</span><span class="p">)</span>                         <span class="c1"># [k, b] @ [b, k] -&gt; HTH  [k, k]</span>
                    <span class="n">WHHT</span> <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="n">HHT</span><span class="p">)</span>                                 <span class="c1"># [m, k] @ [k, k] -&gt; WHHT [m, k]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">XHT</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">HT</span><span class="p">,</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>           <span class="c1"># [b, n].T @ [b, k] -&gt; [n, k].T -&gt; [k, n]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">XHT</span> <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">HT</span><span class="p">)</span>                     <span class="c1"># [m, b] @ [b, k] -&gt; xht  [m, k]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="c1">#del HT, HHT </span>
                    <span class="c1">#self.MEMPOOL.free_all_blocks()</span>
                    <span class="n">dt_w</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
            <span class="c1">#[7] Aggregate Global WHHT and XHT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WHHT</span><span class="p">,</span> <span class="n">WHHT</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="n">dt_reduce1</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">XHT</span><span class="p">,</span> <span class="n">XHT</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="n">dt_reduce2</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
            <span class="c1">#[8] Finalize W-Update</span>
            <span class="n">WHHT</span>     <span class="o">=</span>  <span class="n">WHHT</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="n">XHT</span>      <span class="o">=</span> <span class="n">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="n">XHT</span><span class="p">)</span>                                <span class="c1"># [m, k] * [m, k] -&gt;      [m, k]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">XHT</span><span class="p">,</span> <span class="n">WHHT</span><span class="p">)</span>                                      <span class="c1"># [m, k] / [m, k] -&gt;      [m, k]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
            <span class="n">dt_w</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
            <span class="c1">#[9] Accumulate iteration performance metric</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">]</span>        <span class="o">+=</span> <span class="n">dt_w</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">]</span>        <span class="o">+=</span> <span class="n">dt_h</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WHHT&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt_reduce1</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_XHT&#39;</span><span class="p">]</span>  <span class="o">+=</span> <span class="n">dt_reduce2</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="c1">#[10]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#if self.A_is_Large:</span>
                <span class="c1">#    self.H_h = np.maximum(self.H_h, self.eps)</span>
                <span class="c1">#else:</span>
                <span class="c1">#    self.H_d = cp.maximum(self.H_d, self.eps)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>

        <span class="c1">#[10] Compute Average  performance metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">]</span>        <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">]</span>        <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_XHT&#39;</span><span class="p">]</span>  <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WHHT&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;NMF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
        <span class="c1">#[11] Calculate relative error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_err</span><span class="p">()</span></div>



<div class="viewcode-block" id="cudaNMF.FroNMF_1D_row_partion"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.FroNMF_1D_row_partion">[docs]</a>    <span class="k">def</span> <span class="nf">FroNMF_1D_row_partion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs Frobenius Norm Non-negative Matrix Factorization (FroNMF)</span>
<span class="sd">        on a 1D row partitioned matrix.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - factors: Initial guess for the factors (Optional)</span>
<span class="sd">        - save_factors: Boolean, whether to save the computed factors or not (Default is False)</span>
<span class="sd">        - rtrn: Boolean, whether to return the factors (Default is False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># [1] Monitor initial memory usage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; FroNMF_1D_row_partion() 0&quot;</span><span class="p">)</span>

        <span class="c1"># [2] Initialization of perturbed cofactors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_factors</span><span class="p">()</span>
        <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() init_factors OK&quot;)</span>
        <span class="c1"># [3] Initialize various accumulators for performance measurement and computation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTX&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTWH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

        <span class="c1"># Main iterative loop for NMF computation</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">):</span>
            <span class="c1"># Initialize accumulators for this iteration</span>
            <span class="n">dt_w</span><span class="p">,</span> <span class="n">dt_h</span><span class="p">,</span> <span class="n">dt_reduce1</span><span class="p">,</span> <span class="n">dt_reduce2</span>   <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

            <span class="c1"># [4] Setup for W matrix update</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">W_update</span><span class="p">:</span>
                <span class="n">HT</span>   <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="o">.</span><span class="n">T</span>                                             <span class="c1"># HT [n, k]</span>
                <span class="n">HHT</span>  <span class="o">=</span>  <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="n">HT</span><span class="p">)</span>                                  <span class="c1"># [k, n] @ [n, k] -&gt; HHT  [k, k]</span>

            <span class="c1"># Initialize accumulators for batch computations</span>
            <span class="n">WTWH</span> <span class="o">=</span> <span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>   <span class="c1"># WTWH [k, n] # ACCUMULATOR for WT@W@H</span>
            <span class="n">WTX</span>  <span class="o">=</span> <span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_glob_n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>   <span class="c1"># WTX  [k, n] # ACCUMULATOR for WT@A</span>

            <span class="c1"># [5] Batching loop for local computations</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="c1"># Determine current batch range</span>
                <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 2 b%04d&quot; %b)</span>
                <span class="c1">#[6]////////////////////////////  (W update)&gt; ////////////////////////////////////////////////////////</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">W_update</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="n">WHHT</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:],</span> <span class="n">HHT</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>          <span class="c1"># [b, k] @ [k, k] -&gt; WHHT [b, k]</span>
                    <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 3 b%04d&quot; %b)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">XHT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">HT</span><span class="p">,</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>       <span class="c1"># [b, n] @ [n, k] -&gt; XHT  [b, k]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">XHT</span>  <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">HT</span><span class="p">)</span>                      <span class="c1"># [b, n] @ [n, k] -&gt; XHT  [b, k]</span>
                    <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 4 b%04d&quot; %b)</span>
                    <span class="n">XHT</span>  <span class="o">=</span> <span class="n">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:],</span> <span class="n">XHT</span><span class="p">)</span>                   <span class="c1"># [b, k] * [b, k] -&gt; WXHT [b, k]</span>
                    <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 5 b%04d&quot; %b)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">XHT</span><span class="p">,</span> <span class="n">WHHT</span><span class="p">)</span>                     <span class="c1"># [b, k] / [b, k] -&gt; W    [b, k]</span>
                    <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() W-up  b%04d OK&quot; %b)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="k">del</span>  <span class="n">WHHT</span><span class="p">,</span> <span class="n">XHT</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
                    <span class="n">dt_w</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
                <span class="c1">#[7]////////////////////////////  (H update)&gt; ////////////////////////////////////////////////////////</span>
                <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 7&quot;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="n">WT</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>                                     <span class="c1"># [b, k].T        -&gt; WT   [k, b]</span>
                <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 8&quot;)</span>
                <span class="n">WTW</span>  <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:])</span>                          <span class="c1"># [k, b] @ [b, k] -&gt; WTW  [k, k]</span>
                <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 9&quot;)</span>
                <span class="c1">#print(f&quot;[!!!][iter %04d | batch %04d] shape(WTW)={WTW.shape} || shape(H_d) = {self.H_d.shape}&quot; %(i, b))</span>
                <span class="n">WTWH</span> <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WTW</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">)</span>                                 <span class="c1"># [k, k] @ [k, n] -&gt; WTWH [k, n]</span>
                <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 10 &quot;)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                    <span class="n">WTX</span>  <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:],</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># [b, n].T @ [b, k] -&gt; [n, k].T -&gt; [k, n]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">WTX</span>  <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>                    <span class="c1"># [k, b] @ [b, n] -&gt; WTX  [k, n]</span>
                <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() H-up B%04d OK&quot; %b)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="c1"># Free memory from intermediate variables</span>
                <span class="k">del</span> <span class="n">WT</span><span class="p">,</span> <span class="n">WTW</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
                <span class="n">dt_h</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>

            <span class="c1"># Free memory from intermediate variable</span>
            <span class="k">del</span> <span class="n">HHT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
            <span class="c1"># [8] Aggregate global WTWH and WTX values (used for multi-GPU setup)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Perform Allreduce operation on WTWH and WTX</span>
                <span class="c1"># This is to aggregate results from all GPUs</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WTWH</span><span class="p">,</span> <span class="n">WTWH</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="n">dt_reduce1</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTX</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="n">dt_reduce2</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
            <span class="c1"># [9] Update H with global results</span>
            <span class="n">WTWH</span>     <span class="o">=</span>  <span class="n">WTWH</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 12&quot;)</span>
            <span class="n">WTX</span>      <span class="o">=</span> <span class="n">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="n">WTX</span><span class="p">)</span>                                <span class="c1"># [k, n] * [k, n] -&gt;      [k, n]</span>
            <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() 13&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTWH</span><span class="p">)</span>                                      <span class="c1"># [k, n] / [k, n] -&gt;      [k, n]</span>
            <span class="c1">#self.showMemStats(msg = &quot; FroNMF_1D_row_partion() NMF OK&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
            <span class="n">dt_h</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
            <span class="c1"># Accumulate iteration performance metric</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">]</span>        <span class="o">+=</span> <span class="n">dt_w</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">]</span>        <span class="o">+=</span> <span class="n">dt_h</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTX&#39;</span><span class="p">]</span>  <span class="o">+=</span> <span class="n">dt_reduce1</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTWH&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt_reduce2</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="c1">#[10] Clipping to ensure non-negativity after every 10 iterations</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#if self.A_is_Large:</span>
                <span class="c1">#    self.H_h = np.maximum(self.H_h, self.eps)</span>
                <span class="c1">#else:</span>
                <span class="c1">#    self.H_d = cp.maximum(self.H_d, self.eps)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; FroNMF_1D_row_partion() NMF OK&quot;</span><span class="p">)</span>
        <span class="c1"># [11] Compute Average Performance metrics over all iterations</span>
        <span class="k">del</span> <span class="n">WTWH</span><span class="p">,</span>  <span class="n">WTX</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; FroNMF_1D_row_partion() ALL DELETIONS DONE&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">]</span>        <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">]</span>        <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTX&#39;</span><span class="p">]</span>  <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTWH&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;NMF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
        <span class="c1"># [12] Calculate relative error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; FroNMF_1D_row_partion() BEFORE ERROR Eval&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recon_err</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relative_err</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; FroNMF_1D_row_partion() AFTER  ERROR Eval&quot;</span><span class="p">)</span>
        <span class="c1"># Free all memory blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MEMPOOL</span><span class="o">.</span><span class="n">free_all_blocks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showMemStats</span><span class="p">(</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot; FroNMF_1D_row_partion() LAST CALL MEM POOL FReed OK&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="cudaNMF.FroNMF_1D_row_batched"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.FroNMF_1D_row_batched">[docs]</a>    <span class="k">def</span> <span class="nf">FroNMF_1D_row_batched</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1">#W.I.P</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Frobenius Norm Non-negative Matrix Factorization (FroNMF) for the 1D row of the data matrix</span>
<span class="sd">        using a batched approach.</span>

<span class="sd">        Args:</span>
<span class="sd">        - factors: Not used in this function but could represent the initial factors for matrix factorization.</span>
<span class="sd">        - save_factors: A boolean flag to determine if factors should be saved.</span>
<span class="sd">        - rtrn: A boolean flag to determine if the function should return some values (not implemented yet).</span>

<span class="sd">        Returns:</span>
<span class="sd">        - None (but updates internal attributes of the object and potentially could return some values based on `rtrn` flag).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#[1] Initialize perturbed cofactors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_factors</span><span class="p">()</span>
        <span class="c1">#[2] Initialize accumulators and record the start event for NMF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTX&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTWH&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_A&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_W&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;D2H_W&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">SQ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_managed_stream_queue</span><span class="p">()</span>                             <span class="c1"># Get Managed stream Queue</span>

        <span class="c1"># Loop for the number of iterations (NMF optimization steps)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">):</span>
            <span class="c1">#[3] Initialize iteration Accumulators</span>
            <span class="n">dt_w</span><span class="p">,</span> <span class="n">dt_h</span><span class="p">,</span> <span class="n">dt_reduce1</span><span class="p">,</span> <span class="n">dt_reduce2</span>   <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">W_update</span><span class="p">:</span>
                <span class="n">HT</span>   <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="o">.</span><span class="n">T</span>                                             <span class="c1"># HT [n, k]</span>
                <span class="n">HHT</span>  <span class="o">=</span>  <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="n">HT</span><span class="p">)</span>                                  <span class="c1"># [k, n] @ [n, k] -&gt; HHT  [k, k]</span>
            <span class="c1">#WTWH = _zeros((self.k, self.grid_glob_n), dtype=self.A_ij.dtype)   # WTWH [k, n] # ACCUMULATOR for WT@W@H</span>
            <span class="c1">##WTX  = _zeros((self.k, self.grid_glob_n), dtype=self.A_ij.dtype)   # WTX  [k, n] # ACCUMULATOR for WT@A</span>
            <span class="n">WTX</span><span class="p">,</span> <span class="n">WTWH</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">H2D_A</span><span class="p">,</span> <span class="n">H2D_W</span><span class="p">,</span> <span class="n">D2H_W</span><span class="p">,</span> <span class="n">W_up</span><span class="p">,</span> <span class="n">H_up</span><span class="p">,</span> <span class="n">AR_1</span><span class="p">,</span> <span class="n">AR_2</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="c1">#[4] Start processing data in batches</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                <span class="n">st_key</span> <span class="o">=</span> <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;Queue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>                                              <span class="c1"># Get stream from the queue. If queue is empty, wait until a stream is available.</span>
                <span class="n">stream</span> <span class="o">=</span> <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;READY&#39;</span><span class="p">][</span><span class="n">st_key</span><span class="p">]</span>
                <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
                <span class="c1">#strm_idx  = b % self.MAXSTREAMS</span>
                <span class="c1">#strm_name = self.stream[strm_idx]</span>
                <span class="c1">#stream    = self.STREAMS[strm_name]</span>
                <span class="k">with</span> <span class="n">stream</span><span class="p">:</span>
                    <span class="n">Q_idx</span> <span class="o">=</span> <span class="n">b</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span>
                    <span class="c1">#stream.wait_event(self.FREE_STREAM[strm_name])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="n">H2D_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_e&#39;</span><span class="p">])</span> <span class="p">)</span>  <span class="c1"># [ms]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span> <span class="c1"># CopyH2D_Async Sparse array</span>
                        <span class="c1">#print(f&quot;[!!] [itr %04d][b %02d] type(X_per[b])= {self.X_per[b].dtype}&quot; %(i,b))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">buff_idx</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_idx</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">buff_ptr</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_ptr</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="c1"># CopyH2D_Async</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="c1">#print(f&quot;[!!] [itr %04d][b %02d] H2D_A = {cp.cuda.get_elapsed_time(self.events[&#39;h2d_s&#39;], self.events[&#39;h2d_e&#39;])}&quot; %(i,b))</span>
                    <span class="n">H2D_A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;h2d_e&#39;</span><span class="p">])</span> <span class="p">)</span>  <span class="c1"># [ms]</span>

                    <span class="c1">#[5]////////////////////////////  (W update)&gt; ////////////////////////////////////////////////////////</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">W_update</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                        <span class="n">WHHT</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span> <span class="n">HHT</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>          <span class="c1"># [b, k] @ [k, k] -&gt; WHHT [b, k]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                            <span class="c1">#XHT  = self.MM(self.X_per[p], HT, transpA=False)       # [b, n] @ [n, k] -&gt; XHT  [b, k] </span>
                            <span class="c1">#print(f&quot;[!!] BS = {self.batch_size} || vect_size_dat = {self.sparse_vect_size[&#39;dat&#39;][b]}, vect_size_idx = {self.sparse_vect_size[&#39;idx&#39;][b]}, vect_size_ptr = {self.sparse_vect_size[&#39;ptr&#39;][b]},&quot;)</span>
                            <span class="n">X_d</span> <span class="o">=</span> <span class="n">cupyx</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">][:</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">][</span><span class="n">b</span><span class="p">]],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">buff_idx</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">][:</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">b</span><span class="p">]],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">buff_ptr</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">][:</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;ptr&#39;</span><span class="p">][</span><span class="n">b</span><span class="p">]]),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_loc_n</span><span class="p">))</span>
                            <span class="c1">#print(f&quot;[!!] shape(X_d) ={X_d.shape} ||  shape(HT) = {HT.shape} || BS = {self.batch_size} || vect_size_dat = {self.sparse_vect_size[&#39;dat&#39;][b]}&quot;)</span>
                            <span class="c1">#XHT  = self.MM(X_d, HT, transpA=False)                 # [b, n] @ [n, k] -&gt; XHT  [s, k]</span>
                            <span class="n">XHT</span>   <span class="o">=</span> <span class="n">X_d</span> <span class="o">@</span> <span class="n">HT</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1">#XHT  = _matmul(self.X_per[b], HT)                      # [b, n] @ [n, k] -&gt; XHT  [b, k]</span>
                            <span class="n">XHT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span> <span class="n">HT</span><span class="p">)</span>                     <span class="c1"># [b, n] @ [n, k] -&gt; XHT  [s, k]</span>
                        <span class="c1">#XHT  = _multiply(self.W_d[i0:i1,:], XHT)                   # [b, k] * [b, k] -&gt; WXHT [b, k]</span>
                        <span class="c1">#self.W_d[i0:i1,:] = _divide(XHT, WHHT)                     # [b, k] / [b, k] -&gt; W    [b, k]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span>   <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span> <span class="n">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span> <span class="n">XHT</span><span class="p">),</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span><span class="n">HHT</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span> <span class="c1"># [bs,k] &lt;- ([bs,k]*[bs,k]) / ([bs,k]@[k, k] + epsi)</span>
                        <span class="c1">#WT  = self.W_d[Q_idx].T                                     # [k, b]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;d2h_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>                   <span class="c1"># CopyD2H_Async W_d -&gt; W_h</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;d2h_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;d2h_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                        <span class="n">D2H_W</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;d2h_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;d2h_e&#39;</span><span class="p">])</span> <span class="p">)</span>  <span class="c1"># [ms]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                        <span class="c1">#del  WHHT, XHT</span>
                        <span class="c1">#self.MEMPOOL.free_all_blocks()</span>
                        <span class="n">W_up</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span> <span class="p">)</span>  <span class="c1"># [ms]</span>
                    <span class="c1">#[6]////////////////////////////  (H update)&gt; ////////////////////////////////////////////////////////</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="c1">#WT   = self.W_d[i0:i1,:].T                                    # [b, k].T        -&gt; WT   [k, b]</span>
                    <span class="n">WT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>                                        <span class="c1"># [b, k].T        -&gt; WT   [k, b]</span>
                    <span class="c1">#WTW  = _matmul(WT, self.W_d[i0:i1,:])                          # [k, b] @ [b, k] -&gt; WTW  [k, k]</span>
                    <span class="n">WTW</span>  <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">])</span>                          <span class="c1"># [k, b] @ [b, k] -&gt; WTW  [k, k]</span>
                    <span class="c1">#print(f&quot;[!!!][iter %04d | batch %04d] shape(WTW)={WTW.shape} || shape(H_d) = {self.H_d.shape}&quot; %(i, b))</span>
                    <span class="c1">#WTWH += _matmul(WTW, self.H_d)                                 # [k, k] @ [k, n] -&gt; WTWH [k, n]</span>
                    <span class="n">WTWH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="n">WTW</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">))</span>                            <span class="c1"># [k, k] @ [k, n] -&gt; WTWH [k, n]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="c1">#WTX  += self.MM(X_d, self.W_d[Q_idx], transpA=True).T # [b, n].T @ [b, k] -&gt; [n, k].T -&gt; [k, n]</span>
                        <span class="n">WTX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="n">X_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="c1"># [b, n].T @ [b, k] -&gt; [n, k].T -&gt; [k, n]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#WTX  += _matmul(WT, self.X_d[Q_idx])                    # [k, b] @ [b, n] -&gt; WTX  [k, n]</span>
                        <span class="n">WTX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]))</span>                    <span class="c1"># [k, b] @ [b, n] -&gt; WTX  [k, n]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="c1">#del WT, WTW </span>
                    <span class="c1">#self.MEMPOOL.free_all_blocks()</span>
                    <span class="n">H_up</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]))</span> <span class="c1"># [ms]</span>
                    <span class="n">completed_event</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;COMPLETED&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">completed_event</span><span class="p">)</span>
                    <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;Queue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">st_key</span><span class="p">)</span>
            <span class="c1"># Make sure all streams are done</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;COMPLETED&#39;</span><span class="p">])):</span>
                <span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;REDUCE&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">wait_event</span><span class="p">(</span><span class="n">SQ</span><span class="p">[</span><span class="s1">&#39;COMPLETED&#39;</span><span class="p">][</span><span class="n">b</span><span class="p">])</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Device</span><span class="p">()</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>

            <span class="c1"># Local reduces</span>
            <span class="n">WTWH</span><span class="p">,</span> <span class="n">WTX</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">WTWH</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">WTX</span><span class="p">)</span>
            <span class="c1">#device.synchronize() # Wait for Local reduce to finish</span>
            <span class="c1">#[7] GLOBAL REDUCE: Aggregate Global WTWH and WTX</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nGPUs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WTWH</span><span class="p">,</span> <span class="n">WTWH</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="n">dt_reduce1</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTX</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="n">dt_reduce2</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
            <span class="c1">#[8] Perform H-Update</span>
            <span class="n">WTWH</span>     <span class="o">=</span>  <span class="n">WTWH</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="n">WTX</span>      <span class="o">=</span> <span class="n">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="n">WTX</span><span class="p">)</span>                                <span class="c1"># [k, n] * [k, n] -&gt;      [k, n]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTWH</span><span class="p">)</span>                                      <span class="c1"># [k, n] / [k, n] -&gt;      [k, n]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
            <span class="n">dt_h</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
            <span class="c1">#[9] Accumulate iteration performance metric</span>
            <span class="c1">#print(f&quot;[!!] [itr %04d]  H2D_A = {sum(H2D_A)}&quot; %i)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">]</span>        <span class="o">+=</span> <span class="n">dt_w</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">]</span>        <span class="o">+=</span> <span class="n">dt_h</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTX&#39;</span><span class="p">]</span>  <span class="o">+=</span> <span class="n">dt_reduce1</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTWH&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dt_reduce2</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_A&#39;</span><span class="p">]</span>       <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">H2D_A</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_W&#39;</span><span class="p">]</span>       <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">H2D_W</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;D2H_W&#39;</span><span class="p">]</span>       <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">D2H_W</span><span class="p">)</span>
            <span class="c1">#[10]</span>
            <span class="c1">#if i % 2000 == 0:</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
            <span class="c1">#self.relative_err()</span>
            <span class="c1">#print(f&quot;[+] [iter%08d] err = {self.recon_err}&quot; %i)</span>

        <span class="c1">#[10] Compute Average  performance metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">]</span>        <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">]</span>        <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTX&#39;</span><span class="p">]</span>  <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_WTWH&#39;</span><span class="p">]</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_A&#39;</span><span class="p">]</span>       <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_W&#39;</span><span class="p">]</span>       <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;D2H_W&#39;</span><span class="p">]</span>       <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[!!!!] H2D(A) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_A&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> | H2D(W) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H2D_W&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> | D2H(W) = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;D2H_W&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="kc">False</span><span class="p">:</span> <span class="c1">#i % 10 == 0:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;NMF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">])</span>
            <span class="c1">#self.W_d, self.H_d = self.normalize_features(self.W_d, self.H_d)</span>
            <span class="c1">#self.normalize_features()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">recon_err</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relative_err</span><span class="p">()</span>
                <span class="c1">#self.recon_err = 0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[!] NOT OOOOOOOOK   i = </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> | self.params.itr = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="w"> </span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">SQ</span></div>




<div class="viewcode-block" id="cudaNMF.FroNMF_1D_col"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.FroNMF_1D_col">[docs]</a>    <span class="k">def</span> <span class="nf">FroNMF_1D_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs Frobenius Non-negative Matrix Factorization (NMF) using</span>
<span class="sd">        1D column-based partitioning with GPU acceleration.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - factors : (Optional) Initial values for matrix factors.</span>
<span class="sd">        - save_factors : (Optional) If True, saves factorized matrices.</span>
<span class="sd">        - rtrn : (Optional) If True, returns factorized matrices.</span>

<span class="sd">        Returns:</span>
<span class="sd">        - Factors (if rtrn=True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[!!!] in NMF_ROW_BACHED&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_factors</span><span class="p">()</span>
        <span class="n">xht</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">WTW</span><span class="p">,</span> <span class="n">WTX</span>                       <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">NMF_avg</span><span class="p">,</span> <span class="n">H_avg</span><span class="p">,</span> <span class="n">W_avg</span><span class="p">,</span> <span class="n">red0_avg</span><span class="p">,</span> <span class="n">red1_avg</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">GLOBAL_NORMX</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">):</span>
            <span class="n">dt_wt</span><span class="p">,</span><span class="n">dt_wtw</span><span class="p">,</span><span class="n">dt_wtx</span>                                     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">dt_HHT</span><span class="p">,</span> <span class="n">dt_WHHT</span><span class="p">,</span> <span class="n">dt_xht</span><span class="p">,</span> <span class="n">dt_wxht</span><span class="p">,</span> <span class="n">dt_reduce0</span><span class="p">,</span><span class="n">dt_reduce1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">W_update</span><span class="p">:</span>
                    <span class="c1">#////////////////////////////  (W update)&gt; ////////////////////////////////////////////////////////</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="n">HT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="o">.</span><span class="n">T</span>
                    <span class="n">HHT</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="n">HT</span><span class="p">)</span>                                <span class="c1"># [k, n]@[n,k] -&gt; HHT [k,k]</span>
                    <span class="n">WTX</span><span class="p">,</span> <span class="n">WTWH</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBatch</span><span class="p">):</span>
                        <span class="c1">#print(&quot;[!!!!!!][FroNMF_1D_col][5] len(self.H_d) = {}&quot;.format(len(self.H_d)))</span>
                        <span class="n">strm_idx</span>  <span class="o">=</span> <span class="n">p</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAXSTREAMS</span>
                        <span class="n">strm_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">[</span><span class="n">strm_idx</span><span class="p">]</span>
                        <span class="n">stream</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">STREAMS</span><span class="p">[</span><span class="n">strm_name</span><span class="p">]</span>
                        <span class="k">with</span> <span class="n">stream</span><span class="p">:</span>
                            <span class="n">Q_idx</span> <span class="o">=</span> <span class="n">strm_idx</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span>
                            <span class="n">stream</span><span class="o">.</span><span class="n">wait_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FREE_STREAM</span><span class="p">[</span><span class="n">strm_name</span><span class="p">])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="c1"># CopyH2D_Async W_h -&gt; &gt;W_d [bs, k]</span>
                            <span class="n">WT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>         <span class="c1"># [k, bs]</span>
                            <span class="c1">#print(&quot;[+] shape(W_d) = {} | shape(self.W_h) = {}&quot;.format(self.W_d[Q_idx].shape, self.W_h[p].shape))</span>
                            <span class="c1">#print(&quot;[+] shape(H_d) = {} | shape(self.H_h) = {}&quot;.format(self.H_d.shape, HT.shape))</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                                <span class="c1">#print(&quot;[+] shape(X_d) = {} | shape(self.X_h) = {}&quot;.format(self.X_d[Q_idx].shape, self.X_per[p].shape))</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">buff_idx</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_idx</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">buff_ptr</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_ptr</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                                <span class="n">X_d</span> <span class="o">=</span> <span class="n">cupyx</span><span class="o">.</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">][:</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;dat&#39;</span><span class="p">][</span><span class="n">p</span><span class="p">]],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">buff_idx</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">][:</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">p</span><span class="p">]],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">buff_ptr</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">][:</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse_vect_size</span><span class="p">[</span><span class="s1">&#39;ptr&#39;</span><span class="p">][</span><span class="n">p</span><span class="p">]]),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_loc_m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">))</span>
                                <span class="n">XHT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="n">X_d</span><span class="p">,</span> <span class="n">HT</span><span class="p">,</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>        <span class="c1"># [bs, n] @ [n, k] -&gt; XHT [bs, k]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="c1"># CopyH2D_Async</span>
                                <span class="c1">#print(&quot;[+] shape(X_d) = {} | shape(self.X_h) = {}&quot;.format(self.X_d[Q_idx].shape, self.X_per[p].shape))</span>
                                <span class="n">XHT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span> <span class="n">HT</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span>   <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span> <span class="n">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span> <span class="n">XHT</span><span class="p">),</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">],</span><span class="n">HHT</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span> <span class="c1"># [bs,k] &lt;- ([bs,k]*[bs,k]) / ([bs,k]@[k, k] + epsi)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>                   <span class="c1"># CopyD2H_Async W_d -&gt; W_h</span>
                            <span class="c1">#del  HT</span>
                            <span class="c1">#self.MEMPOOL.free_all_blocks()</span>
                            <span class="c1">#////////////////////////////  (H update)&gt; ////////////////////////////////////////////////////////</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                                <span class="n">wtx</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span> <span class="n">WT</span><span class="p">,</span> <span class="n">X_d</span><span class="p">)</span>                           <span class="c1"># [k, bs] @ [bs, n] -&gt; [k, n]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">wtx</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span> <span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">])</span>                           <span class="c1"># [k, bs] @ [bs, n] -&gt; [k, n]</span>
                            <span class="c1">#wtx = _multiply(H, wtx)</span>
                            <span class="n">WTX</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wtx</span><span class="p">)</span>
                            <span class="n">wtw</span>  <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">Q_idx</span><span class="p">])</span>               <span class="c1"># [k, bs] @ [bs, k] -&gt; [k, k]</span>
                            <span class="c1">#print(&quot;[+] shape(wtw) = {} | shape(self.H_d) = {}&quot;.format(wtw.shape, self.H_d.shape))</span>
                            <span class="n">wtwh</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">wtw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">)</span>                            <span class="c1"># [k, k] @ [k, n] -&gt; [k, n]</span>
                            <span class="n">WTWH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wtwh</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">FREE_STREAM</span><span class="p">[</span><span class="n">strm_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="c1"># Block the `REDUCE_STREAM` until all events occur. This does not block host.</span>
                    <span class="c1"># This is not required when reduction is performed in the default (Stream.null)</span>
                    <span class="c1"># stream unless streams are created with `non_blocking=True` flag.</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batchQeueSize</span><span class="p">):</span>
                        <span class="n">strm_idx</span>  <span class="o">=</span> <span class="n">p</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAXSTREAMS</span>
                        <span class="n">strm_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">[</span><span class="n">strm_idx</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">REDUCE_STREAM</span><span class="o">.</span><span class="n">wait_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">FREE_STREAM</span><span class="p">[</span><span class="n">strm_name</span><span class="p">])</span>
                    <span class="c1"># Local reduces</span>
                    <span class="n">WTWH</span><span class="p">,</span> <span class="n">WTX</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">WTWH</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">WTX</span><span class="p">)</span>
                    <span class="c1">#device.synchronize() # Wait for Local reduce to finish</span>
                    <span class="c1"># Global reduce</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WTWH</span><span class="p">,</span> <span class="n">WTWH</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sub_comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTX</span>  <span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sub_comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span> <span class="n">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="n">WTX</span><span class="p">),</span> <span class="n">WTWH</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">eps</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># GPU MATRIX</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Nc</span><span class="p">):</span>
                    <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span>     <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span>
                    <span class="c1">#print(f&quot;[?] shape(self.X_per[p]) = {self.X_per[p].shape}&quot;)</span>
                    <span class="c1">#WTX        = _matmul(WT, self.X_per[:,j0:j1])               # [k, I] @ [I, J] -&gt; [k, J]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">WTX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># [I, J].T @ [I, k] -&gt; [J, k].T -&gt; [k, J]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">WTX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>                        <span class="c1"># [k, I] @ [I, J] -&gt; [k, J]</span>
                    <span class="n">WTWH</span>       <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WTW</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span><span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])</span>                <span class="c1"># [k, k] @ [k, J] -&gt; [k, J]</span>
                    <span class="n">WTWH</span>      <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>                                       <span class="c1"># [k, J]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
                        <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTX</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="n">dt_reduce1</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
                    <span class="n">WTX</span>                <span class="o">=</span>  <span class="n">_multiply</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span><span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">])</span> <span class="c1"># [k, J] * [k, J] -&gt; [k, J]</span>
                    <span class="c1">#WTX               =  _multiply(WTX, h)                  # [k, J] * [k, J] -&gt; [k, J]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">[:,</span> <span class="n">j0</span><span class="p">:</span><span class="n">j1</span><span class="p">]</span> <span class="o">=</span> <span class="n">WTX</span><span class="o">/</span><span class="n">WTWH</span> <span class="c1"># _divide(WTX, WTWH)      # [k, J] / [k, J] -&gt; [k, J] </span>
                    <span class="c1">#del WTWH, WTX</span>
                    <span class="c1">#self.MEMPOOL.free_all_blocks()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="k">del</span> <span class="n">WTWH</span><span class="p">,</span> <span class="n">WTX</span>

            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span> <span class="c1">#i % 10 == 0:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">H_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>    
                    <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;NMF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_end&#39;</span><span class="p">])</span>
                <span class="c1">#self.W_d, self.H_d = self.normalize_features(self.W_d, self.H_d)</span>
                <span class="c1">#self.normalize_features()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                    <span class="n">NORM</span> <span class="o">=</span>  <span class="n">cp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="n">WTW</span><span class="p">,</span> <span class="n">HHT</span><span class="p">))</span>
                    <span class="n">NORM</span> <span class="o">-=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="n">XHT</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">NORM</span><span class="p">,</span> <span class="n">NORM</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span><span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">GLOBAL_NORMX</span> <span class="o">=</span> <span class="n">GLOBAL_NORMX</span> <span class="o">+</span> <span class="n">NORM</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">recon_err</span> <span class="o">=</span> <span class="n">GLOBAL_NORMX</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">relative_err</span><span class="p">()</span></div>


<div class="viewcode-block" id="cudaNMF.FroNMF_1D_row"><a class="viewcode-back" href="../../pyDNMFk.html#pyDNMFk.cudaNMF.cudaNMF.FroNMF_1D_row">[docs]</a>    <span class="k">def</span> <span class="nf">FroNMF_1D_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">factors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_factors</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtrn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span> <span class="c1"># [W.I.P][B.U.G]</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform 1D Matrix Factorization using the Frobenius Norm Minimization (FroNMF).</span>

<span class="sd">        This function updates W and H matrices for matrix factorization, where</span>
<span class="sd">        the original matrix A is approximated as a product of W and H matrices.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - factors (optional): External factors for initialization (if any). Not currently utilized.</span>
<span class="sd">        - save_factors (bool, optional): Flag to decide if intermediate factors should be saved.</span>
<span class="sd">        - rtrn (bool, optional): Flag to decide if factors should be returned. Not currently utilized.&quot;&quot;&quot;</span>

        <span class="c1">##Attributes Updated:</span>
        <span class="c1">#- eps: Machine epsilon for the datatype of A_ij to avoid division by zero.</span>
        <span class="c1">#- params.eps: Machine epsilon parameter.</span>
        <span class="c1">#- Various time tracking events and intermediate matrices for computation.</span>

        <span class="c1">#Notes:</span>
        <span class="c1">#- This function uses CUDA operations and relies heavily on streams and events</span>
        <span class="c1">#  to synchronize and parallelize operations for better performance.</span>
        <span class="c1">#- The function handles both batched and sparse data but has some</span>
        <span class="c1">#  placeholders which suggest further extensions or checks are planned (e.g., for KL updates).</span>
        <span class="c1">#- The &#39;W_update&#39; parameter from params decides if W should be updated in the current iteration.</span>

        <span class="c1">#[Work in Progress - Some features are still being developed.]</span>
        <span class="c1">#[Bug Warning - There might be unresolved bugs in the code.]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_factors</span><span class="p">()</span>
        <span class="n">xht</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">WTW</span><span class="p">,</span> <span class="n">WTX</span>                       <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">NMF_avg</span><span class="p">,</span> <span class="n">H_avg</span><span class="p">,</span> <span class="n">W_avg</span><span class="p">,</span> <span class="n">red0_avg</span><span class="p">,</span> <span class="n">red1_avg</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="c1">#self.prune = var_init(self.params, &#39;prune&#39;, default=True)</span>
        <span class="c1">#if self.prune: self.prune_all()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;nmf_start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
        <span class="n">j0</span><span class="p">,</span> <span class="n">j1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gID</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gID</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">itr</span><span class="p">):</span>
            <span class="n">dt_wt</span><span class="p">,</span><span class="n">dt_wtw</span><span class="p">,</span><span class="n">dt_wtx</span>                                     <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="n">dt_HHT</span><span class="p">,</span> <span class="n">dt_WHHT</span><span class="p">,</span> <span class="n">dt_xht</span><span class="p">,</span> <span class="n">dt_wxht</span><span class="p">,</span> <span class="n">dt_reduce0</span><span class="p">,</span><span class="n">dt_reduce1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
            <span class="c1">#////////////////////////////  (W update)&gt; ////////////////////////////////////////////////////////</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">W_update</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="n">HT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="o">.</span><span class="n">T</span>                                             <span class="c1"># [J, k]</span>
                <span class="n">HHT</span> <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">,</span> <span class="n">HT</span><span class="p">)</span>     <span class="c1"># Local                      # [k, I] @ [I, k] -&gt; [k, k]</span>
                <span class="c1">#self.comm.barrier()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sub_comm</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">HHT</span><span class="p">,</span> <span class="n">HHT</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="n">dt_reduce0</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_HHT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt_reduce0</span><span class="o">*</span><span class="mf">1.0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                  <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span><span class="p">):</span>
                    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span>     <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>
                    <span class="c1">#print(f&quot;[+]!!!!!!!!!! p = {p}, i0-i1 = {i0}-{i1}&quot;)</span>
                    <span class="n">W</span>          <span class="o">=</span> <span class="n">_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># [I, k], In stream 1, create event w_cp</span>
                    <span class="n">X</span>          <span class="o">=</span> <span class="n">_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:],</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># [I, J], In stream 2, create event x_cp </span>
                    <span class="n">WHHT</span>       <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">HHT</span><span class="p">)</span>                   <span class="c1"># [I, k] @ [k, k] -&gt; [I, k], wait w_cp == True, in stream0 </span>
                    <span class="n">WHHT</span>       <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>                         <span class="c1"># [I, k]</span>
                    <span class="n">XHT</span>        <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">HT</span><span class="p">)</span>                    <span class="c1"># [I, J] @ [J, k] -&gt; [I, k], wait x_cp == True, in stream0</span>
                    <span class="n">XHT</span>        <span class="o">=</span> <span class="n">W</span><span class="o">*</span><span class="n">XHT</span>                             <span class="c1"># [I, k] * [I, k] -&gt; [I, k]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Nc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">XHT</span><span class="p">,</span> <span class="n">XHT</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="n">dt_reduce1</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_XHT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt_reduce1</span><span class="o">*</span><span class="mf">1.0</span>
                    <span class="n">W</span>           <span class="o">=</span>  <span class="n">XHT</span><span class="o">/</span><span class="n">WHHT</span>                        <span class="c1"># _divide(XHT, WHHT)      # [I, k] / [I, k] -&gt; [I, k]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span>  <span class="n">_asnumpy</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="c1"># Local host W Update. Note W is the same everywhere</span>
                    <span class="k">del</span> <span class="n">XHT</span><span class="p">,</span> <span class="n">WHHT</span>
                <span class="k">else</span><span class="p">:</span>
                  <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span><span class="p">):</span>
                    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span>     <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>
                    <span class="n">WHHT</span>       <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">HHT</span><span class="p">)</span>           <span class="c1"># [I, k] @ [k, k] -&gt; [I, k] </span>
                    <span class="n">WHHT</span>       <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>                                  <span class="c1"># [I, k]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">XHT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">HT</span><span class="p">,</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>        <span class="c1"># [I, J] @ [J, k] -&gt; [I, k]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#XHT  = _matmul(self.X_per[i0:i1, :], HT)            # [I, J] @ [J, k] -&gt; [I, k]</span>
                        <span class="n">XHT</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">HT</span><span class="p">)</span>            <span class="c1"># [I, J] @ [J, k] -&gt; [I, k]</span>
                    <span class="c1">#print(f&quot;[+] p = {p}, [i0:i1] = [{i0}:{i1}]: SHAPE(W_d) = {self.W_d[i0:i1, :].shape}, SHAPE(XHT)= {XHT.shape}&quot;)</span>
                    <span class="n">XHT</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="n">XHT</span>                     <span class="c1"># [I, k] * [I, k] -&gt; [I, k]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_Nc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nccl_comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">XHT</span><span class="p">,</span> <span class="n">XHT</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">nccl</span><span class="o">.</span><span class="n">NCCL_SUM</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                    <span class="n">dt_reduce1</span> <span class="o">+=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_s&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;reduce_e&#39;</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;allRed_XHT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt_reduce1</span><span class="o">*</span><span class="mf">1.0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">XHT</span><span class="o">/</span><span class="n">WHHT</span> <span class="c1"># _divide(XHT, WHHT)      # [I, k] / [I, k] -&gt; [I, k] </span>
                    <span class="k">del</span> <span class="n">XHT</span><span class="p">,</span> <span class="n">WHHT</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
                <span class="k">del</span> <span class="n">HT</span>
                <span class="n">dt_w</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;W_up&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt_w</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="c1">#////////////////////////////  (H update)&gt; ////////////////////////////////////////////////////////</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="n">WTW</span> <span class="o">=</span> <span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>      <span class="c1"># [k, k]</span>
            <span class="n">WTX</span> <span class="o">=</span> <span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># [k, J]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span><span class="p">):</span>
                    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>
                    <span class="n">W</span>  <span class="o">=</span> <span class="n">_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_h</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># [I, k], In stream 1, create event w_cp</span>
                    <span class="n">X</span>  <span class="o">=</span> <span class="n">_asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:],</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># [I, J], In stream 2, create event x_cp</span>
                    <span class="n">WT</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">T</span>                                           <span class="c1"># [k, I], wait w_cp == True, in stream0</span>
                    <span class="n">WTW</span> <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>                              <span class="c1"># [k, I] @ [I, k] -&gt; [k, k], in stream 0</span>
                    <span class="n">WTX</span> <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>                              <span class="c1"># [k, I] @ [I, J] -&gt; [k, J], wait x_cp == True, in stream0</span>
                    <span class="k">del</span>  <span class="n">WT</span> <span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">X</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span><span class="p">):</span>
                    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>
                    <span class="c1">#W  = self.W_d[i0:i1, :]                           # [I, k]</span>
                    <span class="n">WT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>                          <span class="c1"># [k, I]</span>
                    <span class="n">WTW</span> <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:])</span>             <span class="c1"># [k, I] @ [I, k] -&gt; [k, k]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">WTX</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,:],</span> <span class="n">transpA</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1"># [I, J].T @ [I, k] -&gt; [J, k].T -&gt; [k, J]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#WTX += self.MM(WT, self.X_per[i0:i1,:])       # [k, I] @ [I, J] -&gt; [k, J]</span>
                        <span class="n">WTX</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MM</span><span class="p">(</span><span class="n">WT</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                    <span class="k">del</span>  <span class="n">WT</span> <span class="c1">#,W</span>
            <span class="n">WTWH</span>    <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="n">WTW</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">)</span>                            <span class="c1"># [k, k] @ [k, J] -&gt; [k, J]</span>
            <span class="k">del</span> <span class="n">WTW</span>
            <span class="n">WTWH</span>    <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="n">WTX</span>     <span class="o">=</span> <span class="n">_multiply</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">)</span>                          <span class="c1"># [k, J] * [k, J] -&gt; [k, J]</span>
            <span class="c1">#H       = _divide(WTX, WTW)                               # [k, J] / [k, J] -&gt; [k, J]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span> <span class="o">=</span> <span class="n">_divide</span><span class="p">(</span><span class="n">WTX</span><span class="p">,</span> <span class="n">WTWH</span><span class="p">)</span>                              <span class="c1"># [k, J] / [k, J] -&gt; [k, J]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">WTX</span> <span class="c1">#, WTW</span>
            <span class="n">dt_h</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">get_elapsed_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">])</span>  <span class="c1"># [ms]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">[</span><span class="s1">&#39;H_up&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt_h</span><span class="o">*</span><span class="mf">1.0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_BATCHED</span><span class="p">:</span>
                <span class="n">noSupportFor</span><span class="p">(</span><span class="s2">&quot;KL update for LARGE A_ij&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">WTXWH</span>          <span class="o">=</span> <span class="n">_zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_J</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A_ij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="c1"># WTXWH [k, J]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_Nr</span><span class="p">):</span>
                    <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span>     <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_I</span>
                    <span class="n">XWH</span>        <span class="o">=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="p">)</span>  <span class="c1"># XWH   = W@H       : [I, k] @ [k, J] -&gt; [I, J]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A_IS_SPARSE</span><span class="p">:</span>
                        <span class="n">noSupportFor</span><span class="p">(</span><span class="s2">&quot; SPARSE A_ij&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">XWH</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_per</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">XWH</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>         <span class="c1"># XWH   = X/(XWH+e)  : [I, J] / [I, J] + eps -&gt; [I, J]</span>
                        <span class="n">WTXWH</span>  <span class="o">+=</span> <span class="n">_matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">W_d</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="n">i1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">XWH</span><span class="p">)</span>    <span class="c1"># WTXWH = W.T@XWH@HT : [k, I] @ [I, J] -&gt; [k, J]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H_d</span><span class="o">*</span><span class="n">WTXWH</span><span class="o">/</span><span class="n">X1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">WTXWH</span><span class="p">,</span><span class="n">XWH</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">relative_err</span><span class="p">()</span></div></div>

</pre></div>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Ismael Boureima, Manish Bhattarai
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
       Copyright 2023, LANL.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>